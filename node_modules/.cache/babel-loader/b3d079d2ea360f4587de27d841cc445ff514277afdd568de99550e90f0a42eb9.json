{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst {\n  fetch,\n  Request,\n  Headers\n} = require('./http/fetch');\nconst {\n  TimeoutError,\n  HTTPError\n} = require('./http/error');\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\nconst {\n  URL,\n  URLSearchParams\n} = require('iso-url');\nconst anySignal = require('any-signal');\nconst browserReableStreamToIt = require('browser-readablestream-to-it');\nconst {\n  isBrowser,\n  isWebWorker\n} = require('./env');\nconst all = require('it-all');\n\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n  const start = Date.now();\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = next => {\n      /**\n       * @param {any} res\n       */\n      const fn = res => {\n        clearTimeout(timeoutID);\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n        next(res);\n      };\n      return fn;\n    };\n    promise.then(after(resolve), after(reject));\n  });\n};\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n  async fetch(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options);\n    // @ts-expect-error\n    const headers = new Headers(opts.headers);\n\n    // validate resource type\n    // @ts-expect-error\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    }\n    const url = new URL(resource.toString(), opts.base);\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts;\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams);\n      }\n    }\n    if (json) {\n      opts.body = JSON.stringify(opts.json);\n      headers.set('content-type', 'application/json');\n    }\n    const abortController = new AbortController();\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal]);\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)));\n    }\n\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n    const response = await timeout(fetch(url.toString(), {\n      ...opts,\n      signal,\n      // @ts-expect-error non-browser fetch implementations may take extra options\n      timeout: undefined,\n      headers,\n      // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n      // https://github.com/whatwg/fetch/issues/1254\n      duplex: 'half'\n    }), opts.timeout, abortController);\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n      throw new HTTPError(response);\n    }\n    response.iterator = async function* () {\n      yield* fromStream(response.body);\n    };\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n    return response;\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  post(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'POST'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  get(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'GET'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  put(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'PUT'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  delete(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  options(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, {\n      ...options,\n      method: 'OPTIONS'\n    });\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n    buf = lines[lines.length - 1];\n  }\n  buf += decoder.decode();\n  buf = buf.trim();\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = source => {\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n          return(value) {\n            source.destroy();\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n        };\n      }\n    };\n  }\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return async function* () {\n      try {\n        while (true) {\n          // Read from the stream\n          const {\n            done,\n            value\n          } = await reader.read();\n          // Exit if we're done\n          if (done) return;\n          // Else yield the chunk\n          if (value) {\n            yield value;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }();\n  }\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = value => {\n  return typeof value === 'object' && value !== null && typeof /** @type {any} */value[Symbol.asyncIterator] === 'function';\n};\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = value => {\n  return value && typeof /** @type {any} */value.getReader === 'function';\n};\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\nmodule.exports = HTTP;","map":{"version":3,"names":["fetch","Request","Headers","require","TimeoutError","HTTPError","merge","bind","ignoreUndefined","URL","URLSearchParams","anySignal","browserReableStreamToIt","isBrowser","isWebWorker","all","timeout","promise","ms","abortController","undefined","start","Date","now","timedOut","time","Promise","resolve","reject","timeoutID","setTimeout","abort","after","next","fn","res","clearTimeout","then","defaults","throwHttpErrors","credentials","HTTP","constructor","options","arguments","length","opts","resource","headers","TypeError","url","toString","base","searchParams","transformSearchParams","json","search","body","JSON","stringify","set","AbortController","signal","globalThis","ReadableStream","Blob","response","duplex","ok","handleError","iterator","fromStream","ndjson","chunk","transform","post","method","get","put","delete","source","decoder","TextDecoder","buf","decode","stream","lines","split","i","l","trim","parse","isAsyncIterable","isNodeReadableStream","iter","Symbol","asyncIterator","return","value","destroy","done","isWebReadableStream","reader","getReader","read","releaseLock","Object","prototype","hasOwnProperty","call","streamToAsyncIterator","module","exports"],"sources":["/home/gustavo/blockchain/Marketplace/node_modules/ipfs-utils/src/http.js"],"sourcesContent":["/* eslint-disable no-undef */\n'use strict'\n\nconst { fetch, Request, Headers } = require('./http/fetch')\nconst { TimeoutError, HTTPError } = require('./http/error')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst anySignal = require('any-signal')\nconst browserReableStreamToIt = require('browser-readablestream-to-it')\nconst { isBrowser, isWebWorker } = require('./env')\nconst all = require('it-all')\n\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = (next) => {\n      /**\n       * @param {any} res\n       */\n      const fn = (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n      return fn\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options)\n    // @ts-expect-error\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    // @ts-expect-error\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams)\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)))\n    }\n\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n    const response = await timeout(\n      fetch(\n        url.toString(),\n        {\n          ...opts,\n          signal,\n          // @ts-expect-error non-browser fetch implementations may take extra options\n          timeout: undefined,\n          headers,\n\n          // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n          // https://github.com/whatwg/fetch/issues/1254\n          duplex: 'half'\n        }\n      ),\n      opts.timeout,\n      abortController\n    )\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = async function * () {\n      yield * fromStream(response.body)\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = (source) => {\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value) {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = (value) => {\n  return typeof value === 'object' &&\n  value !== null &&\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = (value) => {\n  return value && typeof /** @type {any} */(value).getReader === 'function'\n}\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = (value) =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = fromStream\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}