{"ast":null,"code":"import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport { asU8A, fromString } from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {}\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport { encode };","map":{"version":3,"names":["Type","encodeCustom","encodeErrPrefix","asU8A","fromString","JSONEncoder","Array","constructor","inRecursive","prefix","buf","recurs","length","type","array","elements","push","map","uint","major","token","is","String","value","isa","i","charCodeAt","negint","bytes","_buf","_token","Error","string","byts","JSON","stringify","tag","float","name","pop","undefined","dp","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","Object","assign"],"sources":["/home/gustavo/blockchain/Marketplace/node_modules/cborg/esm/lib/json/encode.js"],"sourcesContent":["import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport {\n  asU8A,\n  fromString\n} from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {\n  }\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${ encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${ encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport {\n  encode\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}