{"ast":null,"code":"import _classCallCheck from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport { asU8A, fromString } from '../byte-utils.js';\nvar JSONEncoder = /*#__PURE__*/function (_Array, _Type$uint$major, _Type$negint$major, _Type$bytes$major, _Type$string$major, _Type$array$major, _Type$map$major, _Type$tag$major, _Type$float$major) {\n  _inherits(JSONEncoder, _Array);\n  var _super = _createSuper(JSONEncoder);\n  function JSONEncoder() {\n    var _this;\n    _classCallCheck(this, JSONEncoder);\n    _this = _super.call(this);\n    _this.inRecursive = [];\n    return _this;\n  }\n  _createClass(JSONEncoder, [{\n    key: \"prefix\",\n    value: function prefix(buf) {\n      var recurs = this.inRecursive[this.inRecursive.length - 1];\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          recurs.elements++;\n          if (recurs.elements !== 1) {\n            buf.push([44]);\n          }\n        }\n        if (recurs.type === Type.map) {\n          recurs.elements++;\n          if (recurs.elements !== 1) {\n            if (recurs.elements % 2 === 1) {\n              buf.push([44]);\n            } else {\n              buf.push([58]);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: _Type$uint$major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var is = String(token.value);\n      var isa = [];\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n      }\n      buf.push(isa);\n    }\n  }, {\n    key: _Type$negint$major,\n    value: function value(buf, token) {\n      this[Type.uint.major](buf, token);\n    }\n  }, {\n    key: _Type$bytes$major,\n    value: function value(_buf, _token) {\n      throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: Uint8Array\"));\n    }\n  }, {\n    key: _Type$string$major,\n    value: function value(buf, token) {\n      this.prefix(buf);\n      var byts = fromString(JSON.stringify(token.value));\n      buf.push(byts.length > 32 ? asU8A(byts) : byts);\n    }\n  }, {\n    key: _Type$array$major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: Type.array,\n        elements: 0\n      });\n      buf.push([91]);\n    }\n  }, {\n    key: _Type$map$major,\n    value: function value(buf, _token) {\n      this.prefix(buf);\n      this.inRecursive.push({\n        type: Type.map,\n        elements: 0\n      });\n      buf.push([123]);\n    }\n  }, {\n    key: _Type$tag$major,\n    value: function value(_buf, _token) {}\n  }, {\n    key: _Type$float$major,\n    value: function value(buf, token) {\n      if (token.type.name === 'break') {\n        var recurs = this.inRecursive.pop();\n        if (recurs) {\n          if (recurs.type === Type.array) {\n            buf.push([93]);\n          } else if (recurs.type === Type.map) {\n            buf.push([125]);\n          } else {\n            throw new Error('Unexpected recursive type; this should not happen!');\n          }\n          return;\n        }\n        throw new Error('Unexpected break; this should not happen!');\n      }\n      if (token.value === undefined) {\n        throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: undefined\"));\n      }\n      this.prefix(buf);\n      if (token.type.name === 'true') {\n        buf.push([116, 114, 117, 101]);\n        return;\n      } else if (token.type.name === 'false') {\n        buf.push([102, 97, 108, 115, 101]);\n        return;\n      } else if (token.type.name === 'null') {\n        buf.push([110, 117, 108, 108]);\n        return;\n      }\n      var is = String(token.value);\n      var isa = [];\n      var dp = false;\n      for (var i = 0; i < is.length; i++) {\n        isa[i] = is.charCodeAt(i);\n        if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n          dp = true;\n        }\n      }\n      if (!dp) {\n        isa.push(46);\n        isa.push(48);\n      }\n      buf.push(isa);\n    }\n  }]);\n  return JSONEncoder;\n}( /*#__PURE__*/_wrapNativeSuper(Array), Type.uint.major, Type.negint.major, Type.bytes.major, Type.string.major, Type.array.major, Type.map.major, Type.tag.major, Type.float.major);\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" complex map keys are not supported\"));\n  }\n  var keyToken1 = e1[0];\n  var keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" non-string map keys are not supported\"));\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(\"\".concat(encodeErrPrefix, \" unexpected duplicate map keys, this is not supported\"));\n}\nvar defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter: mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport { encode };","map":{"version":3,"names":["Type","encodeCustom","encodeErrPrefix","asU8A","fromString","JSONEncoder","_Array","_Type$uint$major","_Type$negint$major","_Type$bytes$major","_Type$string$major","_Type$array$major","_Type$map$major","_Type$tag$major","_Type$float$major","_inherits","_super","_createSuper","_this","_classCallCheck","call","inRecursive","_createClass","key","value","prefix","buf","recurs","length","type","array","elements","push","map","token","is","String","isa","i","charCodeAt","uint","major","_buf","_token","Error","concat","byts","JSON","stringify","name","pop","undefined","dp","_wrapNativeSuper","Array","negint","bytes","string","tag","float","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","Object","assign"],"sources":["/home/gustavo/blockchain/Marketplace/node_modules/cborg/esm/lib/json/encode.js"],"sourcesContent":["import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport {\n  asU8A,\n  fromString\n} from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {\n  }\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${ encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${ encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport {\n  encode\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}