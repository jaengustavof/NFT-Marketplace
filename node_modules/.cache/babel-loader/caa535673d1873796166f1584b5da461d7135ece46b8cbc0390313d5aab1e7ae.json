{"ast":null,"code":"import _classCallCheck from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/gustavo/blockchain/Marketplace/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\nimport { Token, Type } from 'cborg';\nimport * as cborgJson from 'cborg/json';\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  var cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  var cidString = cid.toString();\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), new Token(Type.string, cidString, cidString.length), new Token(Type.break, undefined, 1)];\n}\nfunction bytesEncoder(bytes) {\n  var bytesString = base64.encode(bytes).slice(1);\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), new Token(Type.map, Infinity, 1), new Token(Type.string, 'bytes', 5), new Token(Type.string, bytesString, bytesString.length), new Token(Type.break, undefined, 1), new Token(Type.break, undefined, 1)];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nvar encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder,\n    Buffer: bytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nvar DagJsonTokenizer = /*#__PURE__*/function (_cborgJson$Tokenizer) {\n  _inherits(DagJsonTokenizer, _cborgJson$Tokenizer);\n  var _super = _createSuper(DagJsonTokenizer);\n  function DagJsonTokenizer(data, options) {\n    var _this;\n    _classCallCheck(this, DagJsonTokenizer);\n    _this = _super.call(this, data, options);\n    _this.tokenBuffer = [];\n    return _this;\n  }\n  _createClass(DagJsonTokenizer, [{\n    key: \"done\",\n    value: function done() {\n      return this.tokenBuffer.length === 0 && _get(_getPrototypeOf(DagJsonTokenizer.prototype), \"done\", this).call(this);\n    }\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      if (this.tokenBuffer.length > 0) {\n        return this.tokenBuffer.pop();\n      }\n      return _get(_getPrototypeOf(DagJsonTokenizer.prototype), \"next\", this).call(this);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var token = this._next();\n      if (token.type === Type.map) {\n        var keyToken = this._next();\n        if (keyToken.type === Type.string && keyToken.value === '/') {\n          var valueToken = this._next();\n          if (valueToken.type === Type.string) {\n            var breakToken = this._next();\n            if (breakToken.type !== Type.break) {\n              throw new Error('Invalid encoded CID form');\n            }\n            this.tokenBuffer.push(valueToken);\n            return new Token(Type.tag, 42, 0);\n          }\n          if (valueToken.type === Type.map) {\n            var innerKeyToken = this._next();\n            if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n              var innerValueToken = this._next();\n              if (innerValueToken.type === Type.string) {\n                for (var i = 0; i < 2; i++) {\n                  var _breakToken = this._next();\n                  if (_breakToken.type !== Type.break) {\n                    throw new Error('Invalid encoded Bytes form');\n                  }\n                }\n                var bytes = base64.decode(\"m\".concat(innerValueToken.value));\n                return new Token(Type.bytes, bytes, innerValueToken.value.length);\n              }\n              this.tokenBuffer.push(innerValueToken);\n            }\n            this.tokenBuffer.push(innerKeyToken);\n          }\n          this.tokenBuffer.push(valueToken);\n        }\n        this.tokenBuffer.push(keyToken);\n      }\n      return token;\n    }\n  }]);\n  return DagJsonTokenizer;\n}(cborgJson.Tokenizer);\nvar decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[42] = CID.parse;\nexport var name = 'dag-json';\nexport var code = 297;\nexport var encode = function encode(node) {\n  return cborgJson.encode(node, encodeOptions);\n};\nexport var decode = function decode(data) {\n  var options = Object.assign(decodeOptions, {\n    tokenizer: new DagJsonTokenizer(data, decodeOptions)\n  });\n  return cborgJson.decode(data, options);\n};","map":{"version":3,"names":["CID","base64","Token","Type","cborgJson","cidEncoder","obj","asCID","cid","cidString","toString","map","Infinity","string","length","break","undefined","bytesEncoder","bytes","bytesString","encode","slice","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","encodeOptions","typeEncoders","Object","Uint8Array","Buffer","number","DagJsonTokenizer","_cborgJson$Tokenizer","_inherits","_super","_createSuper","data","options","_this","_classCallCheck","call","tokenBuffer","_createClass","key","value","done","_get","_getPrototypeOf","prototype","_next","pop","next","token","type","keyToken","valueToken","breakToken","push","tag","innerKeyToken","innerValueToken","i","decode","concat","Tokenizer","decodeOptions","allowIndefinite","allowUndefined","allowNaN","allowInfinity","allowBigInt","strict","useMaps","tags","parse","name","code","node","assign","tokenizer"],"sources":["/home/gustavo/blockchain/Marketplace/node_modules/@ipld/dag-json/esm/index.js"],"sourcesContent":["import { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\nimport {\n  Token,\n  Type\n} from 'cborg';\nimport * as cborgJson from 'cborg/json';\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const cidString = cid.toString();\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1),\n    new Token(Type.string, cidString, cidString.length),\n    new Token(Type.break, undefined, 1)\n  ];\n}\nfunction bytesEncoder(bytes) {\n  const bytesString = base64.encode(bytes).slice(1);\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1),\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, 'bytes', 5),\n    new Token(Type.string, bytesString, bytesString.length),\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder,\n    Buffer: bytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  constructor(data, options) {\n    super(data, options);\n    this.tokenBuffer = [];\n  }\n  done() {\n    return this.tokenBuffer.length === 0 && super.done();\n  }\n  _next() {\n    if (this.tokenBuffer.length > 0) {\n      return this.tokenBuffer.pop();\n    }\n    return super.next();\n  }\n  next() {\n    const token = this._next();\n    if (token.type === Type.map) {\n      const keyToken = this._next();\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next();\n        if (valueToken.type === Type.string) {\n          const breakToken = this._next();\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form');\n          }\n          this.tokenBuffer.push(valueToken);\n          return new Token(Type.tag, 42, 0);\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next();\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next();\n            if (innerValueToken.type === Type.string) {\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next();\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form');\n                }\n              }\n              const bytes = base64.decode(`m${ innerValueToken.value }`);\n              return new Token(Type.bytes, bytes, innerValueToken.value.length);\n            }\n            this.tokenBuffer.push(innerValueToken);\n          }\n          this.tokenBuffer.push(innerKeyToken);\n        }\n        this.tokenBuffer.push(valueToken);\n      }\n      this.tokenBuffer.push(keyToken);\n    }\n    return token;\n  }\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[42] = CID.parse;\nexport const name = 'dag-json';\nexport const code = 297;\nexport const encode = node => cborgJson.encode(node, encodeOptions);\nexport const decode = data => {\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) });\n  return cborgJson.decode(data, options);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}