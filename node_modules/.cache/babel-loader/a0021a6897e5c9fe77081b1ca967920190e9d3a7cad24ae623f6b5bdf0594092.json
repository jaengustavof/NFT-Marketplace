{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode = exports.encode = exports.toGeneral = exports.code = exports.name = void 0;\nconst signing_1 = __importDefault(require(\"./signing\"));\nconst encryption_1 = __importDefault(require(\"./encryption\"));\nconst cbor = __importStar(require(\"@ipld/dag-cbor\"));\nexports.name = 'dag-jose';\nexports.code = 133;\nfunction isDagJWS(jose) {\n  return 'payload' in jose && typeof jose.payload === 'string' && 'signatures' in jose && Array.isArray(jose.signatures);\n}\nfunction isEncodedJWS(jose) {\n  return 'payload' in jose && jose.payload instanceof Uint8Array && 'signatures' in jose && Array.isArray(jose.signatures);\n}\nfunction isEncodedJWE(jose) {\n  return 'ciphertext' in jose && jose.ciphertext instanceof Uint8Array && 'iv' in jose && jose.iv instanceof Uint8Array && 'protected' in jose && jose.protected instanceof Uint8Array && 'tag' in jose && jose.tag instanceof Uint8Array;\n}\nfunction isDagJWE(jose) {\n  return 'ciphertext' in jose && typeof jose.ciphertext === 'string' && 'iv' in jose && typeof jose.iv === 'string' && 'protected' in jose && typeof jose.protected === 'string' && 'tag' in jose && typeof jose.tag === 'string';\n}\nfunction toGeneral(jose) {\n  if (typeof jose === 'string') {\n    const split = jose.split('.');\n    if (split.length === 3) {\n      return signing_1.default.fromSplit(split);\n    } else if (split.length === 5) {\n      return encryption_1.default.fromSplit(split);\n    }\n    throw new Error('Not a valid JOSE string');\n  }\n  if (isDagJWS(jose) || isDagJWE(jose)) {\n    return jose;\n  }\n  throw new Error('Not a valid unencoded JOSE object');\n}\nexports.toGeneral = toGeneral;\nfunction encode(obj) {\n  if (typeof obj === 'string') {\n    obj = toGeneral(obj);\n  }\n  let encodedJose;\n  if (isDagJWS(obj)) {\n    encodedJose = signing_1.default.encode(obj);\n  } else if (isDagJWE(obj)) {\n    encodedJose = encryption_1.default.encode(obj);\n  } else {\n    throw new Error('Not a valid JOSE object');\n  }\n  return new Uint8Array(cbor.encode(encodedJose));\n}\nexports.encode = encode;\nfunction decode(data) {\n  let encoded;\n  try {\n    encoded = cbor.decode(data);\n  } catch (e) {\n    throw new Error('Not a valid DAG-JOSE object');\n  }\n  if (isEncodedJWS(encoded)) {\n    return signing_1.default.decode(encoded);\n  } else if (isEncodedJWE(encoded)) {\n    return encryption_1.default.decode(encoded);\n  } else {\n    throw new Error('Not a valid DAG-JOSE object');\n  }\n}\nexports.decode = decode;","map":{"version":3,"names":["signing_1","__importDefault","require","encryption_1","cbor","__importStar","exports","name","code","isDagJWS","jose","payload","Array","isArray","signatures","isEncodedJWS","Uint8Array","isEncodedJWE","ciphertext","iv","protected","tag","isDagJWE","toGeneral","split","length","default","fromSplit","Error","encode","obj","encodedJose","decode","data","encoded","e"],"sources":["/home/gustavo/blockchain/Marketplace/node_modules/dag-jose/src/index.ts"],"sourcesContent":["import signing, { DagJWS, EncodedJWS } from './signing'\nexport type { DagJWS } from './signing'\nimport encryption, { DagJWE, EncodedJWE } from './encryption'\nexport type { DagJWE } from './encryption'\nimport * as cbor from '@ipld/dag-cbor'\nimport type { ByteView } from 'multiformats/codecs/interface'\n\n// string name of the codec\nexport const name = 'dag-jose'\n\n// integer for the multiformat entry of the codec\nexport const code = 133 // 0x85 https://github.com/multiformats/multicodec/blob/master/table.csv\n\nfunction isDagJWS(jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE): jose is DagJWS | EncodedJWS {\n  return (\n    'payload' in jose &&\n    typeof jose.payload === 'string' &&\n    'signatures' in jose &&\n    Array.isArray(jose.signatures)\n  )\n}\n\nfunction isEncodedJWS(\n  jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE\n): jose is DagJWS | EncodedJWS {\n  return (\n    'payload' in jose &&\n    jose.payload instanceof Uint8Array &&\n    'signatures' in jose &&\n    Array.isArray(jose.signatures)\n  )\n}\n\nfunction isEncodedJWE(\n  jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE\n): jose is DagJWE | EncodedJWE {\n  return (\n    'ciphertext' in jose &&\n    jose.ciphertext instanceof Uint8Array &&\n    'iv' in jose &&\n    jose.iv instanceof Uint8Array &&\n    'protected' in jose &&\n    jose.protected instanceof Uint8Array &&\n    'tag' in jose &&\n    jose.tag instanceof Uint8Array\n  )\n}\n\nfunction isDagJWE(jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE): jose is DagJWE | EncodedJWE {\n  return (\n    'ciphertext' in jose &&\n    typeof jose.ciphertext === 'string' &&\n    'iv' in jose &&\n    typeof jose.iv === 'string' &&\n    'protected' in jose &&\n    typeof jose.protected === 'string' &&\n    'tag' in jose &&\n    typeof jose.tag === 'string'\n  )\n}\n\n/**\n * Create a properly formed DagJWS or DagJWE object, from either a DagJWS, or\n * DagJWE or the compact string form of either.\n * Applying this function on an already valid DagJWS or DagJWE object will be\n * idempotent. So this function can be used to either verify the proper object\n * form, or expand a compact string form and ensure you have the same form\n * of object that you would receive if you performed a round-trip encode/decode.\n */\nexport function toGeneral(jose: DagJWS | DagJWE | string): DagJWS | DagJWE {\n  if (typeof jose === 'string') {\n    const split = jose.split('.')\n    if (split.length === 3) {\n      return signing.fromSplit(split)\n    } else if (split.length === 5) {\n      return encryption.fromSplit(split)\n    }\n    throw new Error('Not a valid JOSE string')\n  }\n  if (isDagJWS(jose) || isDagJWE(jose)) {\n    return jose\n  }\n  throw new Error('Not a valid unencoded JOSE object')\n}\n\nexport function encode(obj: DagJWS | DagJWE | string): ByteView<EncodedJWS | EncodedJWE> {\n  if (typeof obj === 'string') {\n    obj = toGeneral(obj)\n  }\n  let encodedJose\n  if (isDagJWS(obj)) {\n    encodedJose = signing.encode(obj)\n  } else if (isDagJWE(obj)) {\n    encodedJose = encryption.encode(obj)\n  } else {\n    throw new Error('Not a valid JOSE object')\n  }\n  return new Uint8Array(cbor.encode(encodedJose))\n}\n\nexport function decode(data: ByteView<EncodedJWS | EncodedJWE>): DagJWS | DagJWE {\n  let encoded: EncodedJWS | EncodedJWE\n  try {\n    encoded = cbor.decode(data)\n  } catch (e) {\n    throw new Error('Not a valid DAG-JOSE object')\n  }\n  if (isEncodedJWS(encoded)) {\n    return signing.decode(encoded)\n  } else if (isEncodedJWE(encoded)) {\n    return encryption.decode(encoded)\n  } else {\n    throw new Error('Not a valid DAG-JOSE object')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}